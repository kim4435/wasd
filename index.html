<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>바운스 볼 - 이지 모드</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --ball-color: #ffeb3b;
            --double-jump-color: #00d2ff;
            --block-color: #4ecca3;
            --spike-color: #e94560;
            --star-color: #f9d342;
            --text-color: #ffffff;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            font-family: 'Pretendard', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #ui-overlay {
            margin-bottom: 15px;
            color: var(--text-color);
            text-align: center;
            z-index: 5;
            pointer-events: none;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 500px;
            background: #16213e;
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        canvas {
            display: block;
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 100;
            border: 2px solid var(--block-color);
            box-shadow: 0 0 20px rgba(78, 204, 163, 0.3);
        }

        button {
            background: var(--block-color);
            border: none;
            padding: 12px 30px;
            color: #1a1a2e;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            font-size: 1.1rem;
            transition: transform 0.2s;
        }

        button:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>

<div id="ui-overlay">
    <h1 id="stage-display" style="margin: 0; font-size: 1.8rem; letter-spacing: 2px;">STAGE 1</h1>
    <p id="sub-display" style="margin: 8px 0; opacity: 0.8; font-size: 1rem;">전체적인 난이도가 하향되었습니다!</p>
</div>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    <div id="message-box">
        <h2 id="msg-title" style="color: var(--star-color); margin-top: 0;">STAGE CLEAR!</h2>
        <p>다음 단계로 도전하시겠습니까?</p>
        <button onclick="closeMessage()">NEXT STAGE</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const stageDisplay = document.getElementById('stage-display');
    const subDisplay = document.getElementById('sub-display');
    const messageBox = document.getElementById('message-box');

    // Physics & Config
    const GRAVITY = 0.26; // 중력 살짝 감소 (체공 시간 증가)
    const JUMP_FORCE = -7.0; // 점프력 조절
    const MOVE_SPEED = 4.0; // 이동 속도 살짝 증가 (답답함 해소)
    const BALL_RADIUS = 12; // 공 크기 살짝 키움 (충돌 판정 유리)
    const GRID = 40;

    let currentStage = 0;
    let isGameOver = false;
    let ball = { x: 0, y: 0, vx: 0, vy: 0, hasItem: false, canDouble: false };
    let camera = { x: 0, y: 0 };
    let blocks = [], spikes = [], items = [], star = { x: 0, y: 0 };
    let particles = [], ghosts = [];
    let keys = {};

    // 맵 데이터 (범례: 1 블록, 2 가시, 3 시작, 4 별, 5 날개)
    // 맵의 간격을 좁히고 블록을 더 많이 배치하여 난이도를 낮춤
    const stages = [
        [ // 1단계: 연습용
            "                                        ",
            "                                        ",
            "      3                                 ",
            "   11111     11111                      ",
            "11111111111111111111111111  11111  4    ",
            "11111111111111111111111111  111111111111"
        ],
        [ // 2단계: 가시 피하기 (가시 개수 감소)
            "                                        ",
            "                                        ",
            "   3      1111                          ",
            "  1111   1111111   1111                 ",
            "111111221111111221111111    111   1114  ",
            "111111111111111111111111    111111111111"
        ],
        [ // 3단계: 날개 아이템 (아이템 위치를 낮춤)
            "                                        ",
            "               11111                    ",
            "   3   5      1111111                   ",
            "  111111     111111111         1111     ",
            "111111112211111111111111    11111111  4 ",
            "111111111111111111111111    111111111111"
        ],
        [ // 4단계: 낙하 방지턱 추가
            "                                      4 ",
            "                                   1111 ",
            "                   1111         1111111 ",
            "                1111111      11111      ",
            "   3   5    111111        11111         ",
            "  111111    111111                      ",
            "1111111122211111111111111111111111111111"
        ],
        [ // 5단계: 간격 좁히기
            "                                        ",
            "                                     4  ",
            "                                  1111  ",
            "                           1111111      ",
            "              11    111111              ",
            "        111111                          ",
            "   3 5  111111                          ",
            "  1111                                  ",
            "1111112211111111111111111111111111111111"
        ],
        [ // 6단계: 올라가기 (발판 넓힘)
            " 4                                      ",
            " 111                                    ",
            "    111                                 ",
            "       111     111                      ",
            "  3 5      111         111              ",
            " 1111                      111          ",
            "1111122111111111111111111111111111111111"
        ],
        [ // 7단계: 마지막 (도약 발판 추가)
            "                                        ",
            "                                      4 ",
            "                                 111111 ",
            "                            11111       ",
            "                       11111            ",
            "  3  5     1111   11111                 ",
            " 111111                                 ",
            "1111111122111111111111111111111111111111"
        ]
    ];

    const hints = [
        "블록이 넓어져서 점프가 쉬워졌어요!",
        "가시가 줄어들었습니다. 편하게 이동하세요.",
        "날개 아이템으로 여유롭게 도약하세요.",
        "카메라가 가는 방향을 천천히 따라가세요.",
        "발판이 많아졌으니 안심하고 이동하세요.",
        "한 칸씩 계단 오르듯이 올라가면 됩니다.",
        "마지막입니다! 넓은 발판을 믿고 뛰어보세요."
    ];

    function createEffect(x, y, color) {
        for (let i = 0; i < 8; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 1.0,
                color: color
            });
        }
    }

    function initStage(idx) {
        if (idx >= stages.length) {
            alert("모든 스테이지 클리어! 대단하시네요!");
            currentStage = 0;
            idx = 0;
        }

        const map = stages[idx];
        blocks = []; spikes = []; items = [];
        particles = []; ghosts = [];
        isGameOver = false;
        
        stageDisplay.innerText = `STAGE ${idx + 1}`;
        subDisplay.innerText = hints[idx];

        map.forEach((row, r) => {
            for (let c = 0; c < row.length; c++) {
                let x = c * GRID, y = r * GRID + 100;
                if (row[c] === '1') blocks.push({ x, y, w: GRID, h: GRID });
                if (row[c] === '2') spikes.push({ x, y, w: GRID, h: GRID });
                if (row[c] === '3') {
                    ball.x = x + GRID / 2; ball.y = y;
                    ball.vx = 0; ball.vy = 0;
                    ball.hasItem = false; ball.canDouble = false;
                    camera.x = ball.x - canvas.width / 2;
                    camera.y = ball.y - canvas.height / 2;
                }
                if (row[c] === '4') star = { x: x + GRID / 2, y: y + GRID / 2 };
                if (row[c] === '5') items.push({ x: x + GRID / 2, y: y + GRID / 2, active: true });
            }
        });
        messageBox.style.display = 'none';
    }

    function closeMessage() {
        currentStage++;
        initStage(currentStage);
    }

    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if ((e.code === 'Space' || e.code === 'KeyW' || e.code === 'ArrowUp') && !isGameOver) {
            if (ball.hasItem && ball.canDouble) {
                ball.vy = JUMP_FORCE;
                ball.canDouble = false;
                ball.hasItem = false;
                createEffect(ball.x, ball.y, '#00d2ff');
                ghosts.push({ x: ball.x, y: ball.y, r: BALL_RADIUS, a: 1.0 });
            }
        }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    function update() {
        if (isGameOver) return;

        if (keys['ArrowLeft'] || keys['KeyA']) ball.vx = -MOVE_SPEED;
        else if (keys['ArrowRight'] || keys['KeyD']) ball.vx = MOVE_SPEED;
        else ball.vx = 0;

        ball.vy += GRAVITY;
        ball.x += ball.vx;
        ball.y += ball.vy;

        let targetCamX = ball.x - canvas.width / 2;
        let targetCamY = ball.y - canvas.height / 2;
        camera.x += (targetCamX - camera.x) * 0.1;
        camera.y += (targetCamY - camera.y) * 0.1;

        if (ball.y > camera.y + canvas.height + 400) initStage(currentStage);

        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.03;
            if (p.life <= 0) particles.splice(i, 1);
        });
        ghosts.forEach((g, i) => {
            g.a -= 0.05; g.r += 1;
            if (g.a <= 0) ghosts.splice(i, 1);
        });

        blocks.forEach(b => {
            if (ball.x + BALL_RADIUS > b.x && ball.x - BALL_RADIUS < b.x + b.w &&
                ball.y + BALL_RADIUS > b.y && ball.y - BALL_RADIUS < b.y + b.h) {
                
                let oT = (ball.y + BALL_RADIUS) - b.y;
                let oB = (b.y + b.h) - (ball.y - BALL_RADIUS);
                let oL = (ball.x + BALL_RADIUS) - b.x;
                let oR = (b.x + b.w) - (ball.x - BALL_RADIUS);
                let min = Math.min(oT, oB, oL, oR);

                if (min === oT && ball.vy > 0) {
                    ball.y = b.y - BALL_RADIUS; ball.vy = JUMP_FORCE;
                    createEffect(ball.x, ball.y + BALL_RADIUS, '#ffffff');
                } else if (min === oB && ball.vy < 0) {
                    ball.y = b.y + b.h + BALL_RADIUS; ball.vy = 0;
                } else if (min === oL) ball.x = b.x - BALL_RADIUS;
                else if (min === oR) ball.x = b.x + b.w + BALL_RADIUS;
            }
        });

        spikes.forEach(s => {
            if (ball.x + BALL_RADIUS * 0.6 > s.x && ball.x - BALL_RADIUS * 0.6 < s.x + s.w &&
                ball.y + BALL_RADIUS * 0.6 > s.y && ball.y - BALL_RADIUS * 0.6 < s.y + s.h) {
                initStage(currentStage);
            }
        });

        items.forEach(it => {
            if (it.active && Math.hypot(ball.x - it.x, ball.y - it.y) < BALL_RADIUS + 15) {
                it.active = false;
                ball.hasItem = true; ball.canDouble = true;
                createEffect(it.x, it.y, '#9b59b6');
            }
        });

        if (Math.hypot(ball.x - star.x, ball.y - star.y) < BALL_RADIUS + 15) {
            isGameOver = true;
            messageBox.style.display = 'block';
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        ctx.beginPath();
        for(let x = Math.floor(camera.x/GRID)*GRID; x < camera.x+canvas.width; x+=GRID) {
            ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y+canvas.height);
        }
        for(let y = Math.floor(camera.y/GRID)*GRID; y < camera.y+canvas.height; y+=GRID) {
            ctx.moveTo(camera.x, y); ctx.lineTo(camera.x+canvas.width, y);
        }
        ctx.stroke();

        ctx.fillStyle = "#4ecca3";
        blocks.forEach(b => {
            ctx.beginPath();
            ctx.roundRect(b.x + 1, b.y + 1, b.w - 2, b.h - 2, 5);
            ctx.fill();
        });

        ctx.fillStyle = "#e94560";
        spikes.forEach(s => {
            ctx.beginPath();
            ctx.moveTo(s.x + 6, s.y + s.h);
            ctx.lineTo(s.x + s.w / 2, s.y + 10);
            ctx.lineTo(s.x + s.w - 6, s.y + s.h);
            ctx.fill();
        });

        items.forEach(it => {
            if (it.active) {
                ctx.fillStyle = "#00d2ff";
                ctx.beginPath();
                ctx.arc(it.x, it.y + Math.sin(Date.now()/200)*3, 10, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 10; ctx.shadowColor = "#00d2ff";
                ctx.stroke(); ctx.shadowBlur = 0;
            }
        });

        ghosts.forEach(g => {
            ctx.strokeStyle = `rgba(0, 210, 255, ${g.a})`;
            ctx.beginPath(); ctx.arc(g.x, g.y, g.r, 0, Math.PI*2); ctx.stroke();
        });

        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1.0;

        ctx.fillStyle = "#f9d342";
        ctx.font = "bold 34px Arial";
        ctx.textAlign = "center";
        ctx.shadowBlur = 15; ctx.shadowColor = "#f9d342";
        ctx.fillText("★", star.x, star.y + 12);
        ctx.shadowBlur = 0;

        ctx.fillStyle = ball.hasItem ? "#00d2ff" : "#ffeb3b";
        ctx.shadowBlur = 10;
        ctx.shadowColor = ball.hasItem ? "#00d2ff" : "rgba(255, 235, 59, 0.4)";
        ctx.beginPath(); ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();

        update();
        requestAnimationFrame(draw);
    }

    initStage(0);
    draw();
</script>
</body>
</html>
